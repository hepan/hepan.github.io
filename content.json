{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"archives","date":"2019-04-23T05:23:04.000Z","updated":"2019-04-23T05:23:04.931Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-23T02:00:17.000Z","updated":"2019-04-23T02:03:25.548Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-23T01:58:08.000Z","updated":"2019-04-23T02:03:38.095Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"STOMP协议+springboot-websocket","slug":"STOMP协议","date":"2019-04-24T05:28:17.000Z","updated":"2019-05-05T01:24:28.497Z","comments":true,"path":"2019/04/24/STOMP协议/","link":"","permalink":"http://yoursite.com/2019/04/24/STOMP协议/","excerpt":"","text":"介绍stomp是一个协议，主要用于处理发布/订阅模式的消息处理。stomp可以基于websocket构建，这样就可以实现网页与服务器的发布/订阅模式的消息通信了。 http、websocket、stomp的关系HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的。 HTTP不足在于它与服务器的全双工通信依靠轮询实现，对于需要从服务器主动发送数据的情境，会给服务器资源造成很大的浪费，WebSocket是针对HTTP在这种情况下的补充。对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。 WebSocket是一个完整的应用层协议，包含一套标准的 API 。 STOMP即Simple (or Streaming) Text Orientated Messaging Protocol，简单(流)文本定向消息协议，它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。 STOMP协议可以建立在WebSocket之上，也可以建立在其他应用层协议之上。 STOMP.JS stomp.js是对stomp客户端的封装。简化了开发成本，例如心跳处理只需要配置间隔时间完全不用关注具体实现。 提供多种版本供开发使用 stomp.js不仅可以连接常规的stomp服务。还可以连接一些MQ服务。例如,RabbitMQ,ActiveMQ等。STOMP API //TODO 带填 STOMP 帧STOMP帧由命令，一个或多个头信息、一个空行及负载（文本或字节）所组成； 其中可用的COMMAND 包括：CONNECT、SEND、SUBSCRIBE、UNSUBSCRIBE、BEGIN、COMMIT、ABORT、ACK、NACK、DISCONNECT； springboot websocket + stomp.js使用springboot全家桶+stomp.js可以做到快速发布订阅服务。 maven配置1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 代码结构123456789101112131415161718192021222324.├── main│ ├── java│ │ └── io│ │ └── github│ │ └── hepan│ │ └── springboot│ │ └── stomp│ │ └── demo│ │ ├── STOMPApp.java //启动类│ │ ├── config│ │ │ └── WebsocketConfig.java //配置│ │ ├── controller│ │ │ └── MessageController.java //app模式下调用入口│ │ └── websocket│ │ ├── StompUserRepository.java //用户与资源缓存│ │ ├── WebSocketEventerListener.java //websocket监听│ │ └── WebSocketHandlerInterceptor.java //websocket命令拦截器│ └── resources│ └── application.yml└── test └── resource └── static └── stomp-test.html //静态页面 java主要代码需要注意的地方： 1 WebsocketConfig中/app 这个地址用于访问后台的前缀，可以设置多个 例如 测试html中访问后台接口/bind/{resource}时前端需写的地址为 /app/test/user123 2 topic为客户端订阅消息的前缀 3 ws为连接后端服务时用的后缀 WebsocketConfig 用于设置websocket配置12345678910111213141516171819202122232425@Configuration@EnableWebSocketMessageBrokerpublic class WebsocketConfig implements WebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; registry.addEndpoint(\"/ws\").setAllowedOrigins(\"*\").withSockJS(); &#125; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; // 设置接收客户端消息 的 路径前缀（不设置可以） registry.setApplicationDestinationPrefixes(\"/app\"); // 设置接收客户端订阅 的 路径前缀（必须不设置，可以为空串） registry.enableSimpleBroker(\"/topic\"); &#125; @Override public void configureClientInboundChannel(ChannelRegistration registration) &#123; // 添加拦截器，处理客户端发来的请求 registration.interceptors(new WebSocketHandlerInterceptor()); &#125;&#125; WebSocketEventerListener 监听连接与断开事件。12345678910111213141516171819202122232425/** * @author hp * @Description:TODO * @date 2019-04-26 14:59 */public class WebSocketEventerListener &#123; private static final Logger log = LoggerFactory.getLogger(WebSocketEventerListener.class); @Autowired private StompUserRepository userRepository; @EventListener public void handleConnectListener(SessionConnectedEvent event)&#123; log.info(\"[ws-连接] &#123;&#125;\",event.getMessage()); StompHeaderAccessor accessor = StompHeaderAccessor.wrap(event.getMessage()); userRepository.addUser(accessor.getUser()); &#125; @EventListener public void handleDisconnectListener(SessionDisconnectEvent event) &#123; log.info(\"[ws-断开] &#123;&#125;\",event.getMessage()); StompHeaderAccessor accessor = StompHeaderAccessor.wrap(event.getMessage()); userRepository.releaseUser(accessor.getUser()); &#125;&#125; WebSocketHandlerInterceptor commind命令拦截器。可以根据command的不同添加一些自己的预处理逻辑。12345678910111213141516171819202122232425/** * @author hp * @Description:TODO * @date 2019-04-26 15:10 */public class WebSocketHandlerInterceptor implements ChannelInterceptor &#123; @Override public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123; StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class); if(StompCommand.CONNECT.equals(accessor.getCommand()))&#123; String userId=accessor.getFirstNativeHeader(\"userId\"); if(StringUtils.isEmpty(userId))&#123; return null; &#125; Principal principal=new UserPrincipal(userId); accessor.setUser(principal); &#125; return message; &#125;&#125; StompUserRepository 用户与资源的存储，这里有一些业务上的需求。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * @author hp * @Description: 存储用户与资源的绑定关系，一个用户同一时间只占有一个资源。一个资源不可同时被两个用户占有 * @date 2019-04-26 15:26 */@Componentpublic class StompUserRepository &#123; private static final Logger log = LoggerFactory.getLogger(StompUserRepository.class); private static final Map&lt;String , String&gt; userRepo=new ConcurrentHashMap&lt;&gt;(); private static final Map&lt;String ,String&gt; resourceRepo=new ConcurrentHashMap&lt;&gt;(); public boolean addUser(Principal principal)&#123; if(ObjectUtils.isEmpty(principal))&#123; return false; &#125; userRepo.put(principal.getName(),null); return true; &#125; /** * 为user添加resource， * @param principal * @param resource * @return true：添加成功 * false：1-&gt;resource已被占有。2-&gt;入参为null或\"\"。 */ public boolean addRepo(Principal principal,String resource)&#123; if(ObjectUtils.isEmpty(principal)||StringUtils.isEmpty(resource))&#123; return false; &#125; //已经被占有的资源返回错误 String name=resourceRepo.get(resource); if(!StringUtils.isEmpty(name))&#123; return false; &#125; String resInRepo=userRepo.get(principal.getName()); if(!StringUtils.isEmpty(resInRepo))&#123; log.info(\"[SUR] name-&gt;[&#123;&#125;] resource from[&#123;&#125;] to[&#123;&#125;]\",name,resInRepo,resource); &#125; userRepo.put(principal.getName(),resource); resourceRepo.put(resource,principal.getName()); return true; &#125; /** * 释放user与user所占有resource * @param principal * @return */ public boolean releaseUser(Principal principal)&#123; if(ObjectUtils.isEmpty(principal))&#123; return false; &#125; String resource=userRepo.get(principal.getName()); userRepo.remove(principal); resourceRepo.remove(resource); return true; &#125; /** * 释放resource并解除user与resource的绑定关系 * @param resource * @return */ public boolean releaseResource(Principal principal,String resource)&#123; if(StringUtils.isEmpty(resource))&#123; log.info(\"[release-resource] 释放失败 资源isEmpty\"); return false; &#125; if(!userRepo.containsKey(principal.getName()))&#123; log.info(\"[release-resource] 释放失败 资源中未找到[&#123;&#125;]\",principal.getName()); return false; &#125; String name=resourceRepo.get(resource); if(name.equalsIgnoreCase(principal.getName()))&#123; log.info(\"[release-resource] 释放失败 当前绑定资源用户与释放资源用户不一致 resource-&gt;&#123;&#125; from user-&gt;&#123;&#125; to-&gt;&#123;&#125;\" ,resource,name,principal.getName()); return false; &#125; resourceRepo.remove(resource); userRepo.put(name,null); return true; &#125;&#125; MessageController12345678910111213141516171819202122232425262728293031323334353637383940@Controllerpublic class MessageController &#123; private static final Logger log = LoggerFactory.getLogger(MessageController.class); @Autowired private SimpMessagingTemplate simpMessagingTemplate; @Autowired private StompUserRepository stompUserRepository; @MessageMapping(\"/test/&#123;id&#125;\") public void test(Message message, MessageHeaders MessageHeaders, @Header(\"destination\") String destination, @Headers Map&lt;String, Object&gt; headers, @DestinationVariable String id, @Payload String body) &#123; log.info(\"[test] Message: &#123;&#125;\", message); log.info(\"[test] MessageHeaders: &#123;&#125;\", MessageHeaders); log.info(\"[test] Header: &#123;&#125;\", destination); log.info(\"[test] Headers: &#123;&#125;\", headers); log.info(\"[test] DestinationVariable: &#123;&#125;\", id); log.info(\"[test] Payload: &#123;&#125;\", body); System.out.println(id+\"----------\"); &#125; @MessageMapping(\"/bind/&#123;resource&#125;\") public boolean bindResource(Message message, @DestinationVariable String resource)&#123; return stompUserRepository.addRepo(StompHeaderAccessor.wrap(message).getUser(),resource); &#125; @MessageMapping(\"/release/&#123;resource&#125;\") public void releaseResource(Message message,@DestinationVariable String resource)&#123; stompUserRepository.releaseResource(StompHeaderAccessor.wrap(message).getUser(),resource); &#125;&#125; 测试html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script src=\"https://cdn.bootcss.com/stomp.js/2.3.3/stomp.js\"&gt;&lt;/script&gt; &lt;script&gt; const userId = 'mits3333333333333'; var sendMessage = null; var disConnect = null; function connect() &#123; var client = Stomp.client('ws://127.0.0.1:18080/ws/websocket'); client.heartbeat.outgoing = 5000; client.heartbeat.incoming = 0; client.connect(&#123; userId: userId &#125;, function (succ) &#123; console.log('client connect success:', succ); updateState('连接成功'); // // 订阅消息 client.subscribe(\"/topic/bind/123456\",onMessage); &#125;, function (error) &#123; console.log('client connect error:', error); updateState('连接失败'); &#125;); sendMessage = function (destination, headers, body) &#123; client.send(destination, headers, body) &#125;; disConnect = function () &#123; client.disconnect(); console.log('client connect break') &#125;; sendMessage = function (destination, headers, body) &#123; client.send(destination, headers, body) &#125;; &#125; function onMessage(message) &#123; console.log(\"receive message [\"+message.body+\"]\"); //insertChat(false, message.headers.destination, message.body) &#125; function updateState(state) &#123; console.log('[connected] state is --&gt;'+state) &#125; function send(destination,message) &#123; // var destination=document.getElementById(\"destination\").value; // var message=document.getElementById(\"message\").value; // var destination='/topic/bind/123456'; if(sendMessage==null)&#123; console.error(\"ws connect break!!!\"); return ; &#125; sendMessage(destination,&#123;&#125;,message); console.log(\"send message ----&gt;\" +destination +\"*****\"+ message) &#125; &lt;/script&gt; &lt;title&gt;stomp-test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;stomp-test&lt;/h1&gt;&lt;button type=\"button\" id=\"connect\" onclick=\"connect()\"&gt; connect &lt;/button&gt;&lt;br&gt;&lt;button type=\"button\" id=\"send topic message\" onclick=\"send('/topic/bind/123456','this is topic message')\"&gt;sendTopic()&lt;/button&gt;&lt;button type=\"button\" id=\"send app message\" onclick=\"send('/app/test/user123','this is app message')\"&gt;sendApp()&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 基于MQ的STOMP实现stomp.js不仅可以结合spring-websocket使用，还可以介入支持stomp协议的MQ例如 active mq,rabbit mq等。 使用mq处理发布订阅模式的消息1 可以基于mq的基本功能保证消息的可靠性，2 省去了服务端对消息发送接收的代码量。但是也有个很大的弊端就是mq只关心消息发送接收及存储，业务上的一些特殊需求没办法做到扩展(可能有但是没做调查)。如果没有业务扩展建议直接使用可靠度更高的mq。 代码参考https://github.com/hepan/study/tree/master/springboot/stomp-demo 参考资料https://blog.csdn.net/chszs/article/details/46592777 https://blog.csdn.net/HelloXiaoYueYue/article/details/51006069 http://lsxj615.com/2016/08/17/STOMP-over-WebSocket https://www.ibm.com/developerworks/cn/opensource/os-cn-rabbit-mq/index.html https://www.zhihu.com/question/59564853/answer/494835225 https://blog.csdn.net/jqsad/article/details/77745379","categories":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/categories/基础/"}],"tags":[{"name":"STOMP","slug":"STOMP","permalink":"http://yoursite.com/tags/STOMP/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"我的个人博客网站如何搭建的","slug":"这是一个测试页面","date":"2019-04-23T01:15:29.000Z","updated":"2019-04-23T06:28:38.025Z","comments":true,"path":"2019/04/23/这是一个测试页面/","link":"","permalink":"http://yoursite.com/2019/04/23/这是一个测试页面/","excerpt":"","text":"为啥要搭建个人博客作为一个程序员，知识迭代的速度远超其他职业，往往是一边喊着别更新了老子学不动了，可是想想自己还能干啥，好像也不会干别的啥那就只能硬着头继续学啦。 学习的过程中往往是学完了，当时感觉明白过了没几天可能就忘了。人的记忆就是这样，学会了总结成自己的东西才能记得更牢。 现有平台 VS 个人博客网站现有平台(csdn之类) 优点 服务有保证 简单只要负责写就行了","categories":[{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"http://yoursite.com/categories/搭建个人博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-23T00:58:34.700Z","updated":"2019-04-23T00:58:34.700Z","comments":true,"path":"2019/04/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}